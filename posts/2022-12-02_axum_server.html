<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" type="image/svg+xml" href="/favicon.svg"/><link rel="icon" type="image/png" href="/favicon.png"/><link rel="icon" type="image/x-icon" href="/favicon.ico"/><title>/dev/blog - /dev/blog - Axum Server</title><meta name="description" content="Implementing a Web Server in Rust using axum"/><link rel="canonical" href="https://joshuachp.dev/posts/2022-12-02_axum_server"/><meta name="next-head-count" content="9"/><script id="dark-theme" data-nscript="beforeInteractive">if(localStorage.theme==='Dark'||((!('theme'in localStorage)||localStorage.theme==='Auto')&&window.matchMedia('(prefers-color-scheme: dark)').matches)){document.documentElement.classList.add('dark')}</script><link rel="preload" href="/_next/static/css/5fc30b497c9bed6d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5fc30b497c9bed6d.css" data-n-g=""/><link rel="preload" href="/_next/static/css/2a1840b1c557e13c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2a1840b1c557e13c.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2751f6424e24f776.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-f11614d8aa7ee555.js" defer=""></script><script src="/_next/static/chunks/pages/_app-533b7168c81c4665.js" defer=""></script><script src="/_next/static/chunks/424-7590959e48df0588.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpath%5D-22a4d852491b13a0.js" defer=""></script><script src="/_next/static/ySP3GZd7gqZ7dTVrh9Bh0/_buildManifest.js" defer=""></script><script src="/_next/static/ySP3GZd7gqZ7dTVrh9Bh0/_ssgManifest.js" defer=""></script></head><body class="bg-primary-50 dark:bg-primary-900"><div id="__next"><header class="flex flex-row items-baseline justify-between gap-4 p-6 sm:px-12 md:px-24 lg:px-48 xl:px-60 2xl:px-96"><nav class="flex flex-grow flex-row flex-wrap gap-y-4"><a title="Home page" class="mr-8" href="/"><h1 class=" text-primary-900 dark:text-primary-50 text-4xl font-extrabold tracking-tight sm:text-5xl md:text-6xl">/dev/blog</h1></a><ul class="flex flex-grow flex-row items-end justify-start gap-8"><li><a title="Posts" href="/posts"><span class="text-xl md:text-2xl text-primary-900 dark:text-primary-50 underline font-bold">Posts</span></a></li><li><a title="Notes" href="/notes"><span class="text-xl md:text-2xl text-primary-900 dark:text-primary-50  font-bold">Notes</span></a></li></ul></nav><div><button class="rounded border-t-2 border-l-2 border-r-4 border-b-4  border-primary-900 px-4 py-2 text-sm font-medium text-primary-900  hover:bg-primary-100 active:translate-y-0.5 dark:border-primary-50 dark:text-primary-50 dark:hover:bg-primary-800 "><span class="text-sm sm:text-base xl:text-lg text-primary-900 dark:text-primary-50 font-semibold">Auto</span></button></div></header><main class="flex flex-col justify-center p-6 sm:px-12 md:px-24 lg:px-48 xl:px-60 2xl:px-96"><article class="flex max-w-full grow flex-col justify-self-start"><h1 class="mb-4 text-primary-900 dark:text-primary-50 text-4xl font-extrabold tracking-tight sm:text-5xl md:text-6xl"><span>Axum Server</span></h1><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Install required dependencies</span></p><pre class="language-bash mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>cargo add axum
cargo add hyper --features=full
cargo add tokio --features=full
cargo add toker
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Lets create a new function that will return the </span><code class=" items-baseline rounded bg-primary-200 p-0.5 text-sm dark:bg-primary-700 sm:p-1 sm:text-base xl:text-lg">axum::routing::Router</code><span>. This</span>
<span>will be the core of our server.</span></p><pre class="language-rust mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>// src/main.rs
fn app() -&gt; Router {
    Router::new().route(&quot;/&quot;, get(|| async { &quot;Hello, World!&quot; }))
}
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Creating a function that returns the </span><code class=" items-baseline rounded bg-primary-200 p-0.5 text-sm dark:bg-primary-700 sm:p-1 sm:text-base xl:text-lg">Router</code><span> will help us later to test our</span>
<span>application.</span></p><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Add the tokio config to the main function.</span></p><pre class="language-rust mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>// src/main.rs
#[tokio::main]
async fn main() {
// ...
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Create the socket address we will listen on.</span></p><pre class="language-rust mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>// src/main.rs fn main()
let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)), 8080);
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>And bind the address to our application.</span></p><pre class="language-rust mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>// src/main.rs fn main()
axum::Server::bind(&amp;address)
    .serve(app().into_make_service())
    .await
    .unwrap();
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Lets test our server out, in one terminal let</span><span>’</span><span>s start the server and in another</span>
<span>we will use </span><code class=" items-baseline rounded bg-primary-200 p-0.5 text-sm dark:bg-primary-700 sm:p-1 sm:text-base xl:text-lg">curl</code><span> to call the endpoint we just created.</span></p><pre class="language-bash mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span># one terminal
cargo run
# the other terminal
curl 127.0.0.1:8080 # Hello, world!
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Let</span><span>’</span><span>s add an automatic test for the </span><code class=" items-baseline rounded bg-primary-200 p-0.5 text-sm dark:bg-primary-700 sm:p-1 sm:text-base xl:text-lg">/</code><span> route. Lets start by adding the test</span>
<span>that will create our application.</span></p><pre class="language-rust mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>// src/main.rs
#[cfg(test)]
mod test {
    use super::app;

    #[tokio::test]
    async fn hello_world() {
        let app = app();
    }
}
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>The </span><code class=" items-baseline rounded bg-primary-200 p-0.5 text-sm dark:bg-primary-700 sm:p-1 sm:text-base xl:text-lg">#[tokio::test]</code><span> will let us create and async test. Let</span><span>’</span><span>s make the request</span>
<span>for the endpoint inside the test.</span></p><pre class="language-rust mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>// src/main.rs mod test
// dependencies for the response
use axum::{body::Body, http::Request};
use tower::ServiceExt; // for oneshot

#[tokio::test]
async fn hello_world() {
    let app = app();

    let response = app
        .oneshot(Request::builder().uri(&quot;/&quot;).body(Body::empty()).unwrap())
        .await
        .unwrap();
// ...
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Finally let</span><span>’</span><span>s add the assertions to the test.</span></p><pre class="language-rust mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>// src/main.rs mod test fn hello_world()
let response = ...;

assert_eq!(response.status(), StatusCode::OK);

let body = hyper::body::to_bytes(response.into_body()).await.unwrap();
assert_eq!(&amp;body[..], b&quot;Hello, World!&quot;);
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Now we have a working and tested web server. Lets add some more useful</span>
<span>utilities.</span></p><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>The first is </span><a title="" class="font-bold text-accent-700 visited:text-accent-900 hover:underline dark:text-accent-400 dark:visited:text-accent-600" href="https://docs.rs/color-eyre/latest/color_eyre/"><span>color-eyre</span></a><span> to</span>
<span>have a better panic handler.</span></p><pre class="language-bash mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>cargo add color_eyre
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Then, we have to initialize the panic handler.</span></p><pre class="language-rust mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>// src/main.rs
use color_eyre::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    color_eyre::install()?;

    // ...
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Now we can use the </span><code class=" items-baseline rounded bg-primary-200 p-0.5 text-sm dark:bg-primary-700 sm:p-1 sm:text-base xl:text-lg">?</code><span> in the main function instead of </span><code class=" items-baseline rounded bg-primary-200 p-0.5 text-sm dark:bg-primary-700 sm:p-1 sm:text-base xl:text-lg">unwrap</code><span> for errors. You</span>
<span>can try to run two instances of the program at the same time to see an example</span>
<span>of the eyre errors.</span></p><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Finally, we want to log what our server is doing. To do that we will use the</span>
<span>tracing crate, which is already integrated with axum and eyre.</span></p><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>So let</span><span>’</span><span>s install the tracing dependencies.</span></p><pre class="language-bash mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>cargo add tracing
cargo add tracing_subscriber --features=env-filter
cargo add tower_http --features=trace
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Then, in our </span><code class=" items-baseline rounded bg-primary-200 p-0.5 text-sm dark:bg-primary-700 sm:p-1 sm:text-base xl:text-lg">main.rs</code><span> after the eyre install we have to add the tracing</span>
<span>subscriber.</span></p><pre class="language-rust mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>// src/main.rs fn main()
tracing_subscriber::registry()
    .with(
        tracing_subscriber::EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| &quot;example_testing=debug,tower_http=debug&quot;.into()),
    )
    .with(tracing_subscriber::fmt::layer())
    .init();
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Where </span><code class=" items-baseline rounded bg-primary-200 p-0.5 text-sm dark:bg-primary-700 sm:p-1 sm:text-base xl:text-lg">example_testing</code><span> is the name of our application. This will try to parse</span>
<span>the env filter or use </span><code class=" items-baseline rounded bg-primary-200 p-0.5 text-sm dark:bg-primary-700 sm:p-1 sm:text-base xl:text-lg">debug</code><span> as a default for either our application and</span>
<span>tower.</span></p><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Next we add the tracing layer to the tower stack:</span></p><pre class="language-rust mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>// src/main.rs
fn app() -&gt; Router {
    Router::new()
        .route(&quot;/&quot;, get(|| async { &quot;Hello, World!&quot; }))
        .layer(TraceLayer::new_for_http())
}
</span></code></pre><p class="mb-4 inline text-sm text-primary-900 dark:text-primary-50 sm:text-base xl:text-lg"><span>Finally we can start tracing, let</span><span>’</span><span>s add a debug event for the server address.</span></p><pre class="language-rust mb-4 overflow-auto rounded border-2 border-primary-900 p-4 dark:border-primary-50"><code><span>// src/main.rs fn main()
let address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)), 8080);

tracing::debug!(&quot;listing on address {}&quot;, address);
</span></code></pre></article></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"path":"2022-12-02_axum_server","article":{"title":"Axum Server","description":"Implementing a Web Server in Rust using axum","tags":["rust","web","backend"],"date":"2022-12-02","draft":false,"language":"en","content":[{"Start":{"Heading":["H1",null,[]]}},{"Text":"Axum Server"},{"End":{"Heading":["H1",null,[]]}},{"Start":"Paragraph"},{"Text":"Install required dependencies"},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"bash"}}},{"Text":"cargo add axum\ncargo add hyper --features=full\ncargo add tokio --features=full\ncargo add toker\n"},{"End":{"CodeBlock":{"Fenced":"bash"}}},{"Start":"Paragraph"},{"Text":"Lets create a new function that will return the "},{"Code":"axum::routing::Router"},{"Text":". This"},"SoftBreak",{"Text":"will be the core of our server."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"rust"}}},{"Text":"// src/main.rs\nfn app() -\u003e Router {\n    Router::new().route(\"/\", get(|| async { \"Hello, World!\" }))\n}\n"},{"End":{"CodeBlock":{"Fenced":"rust"}}},{"Start":"Paragraph"},{"Text":"Creating a function that returns the "},{"Code":"Router"},{"Text":" will help us later to test our"},"SoftBreak",{"Text":"application."},{"End":"Paragraph"},{"Start":"Paragraph"},{"Text":"Add the tokio config to the main function."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"rust"}}},{"Text":"// src/main.rs\n#[tokio::main]\nasync fn main() {\n// ...\n"},{"End":{"CodeBlock":{"Fenced":"rust"}}},{"Start":"Paragraph"},{"Text":"Create the socket address we will listen on."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"rust"}}},{"Text":"// src/main.rs fn main()\nlet address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)), 8080);\n"},{"End":{"CodeBlock":{"Fenced":"rust"}}},{"Start":"Paragraph"},{"Text":"And bind the address to our application."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"rust"}}},{"Text":"// src/main.rs fn main()\naxum::Server::bind(\u0026address)\n    .serve(app().into_make_service())\n    .await\n    .unwrap();\n"},{"End":{"CodeBlock":{"Fenced":"rust"}}},{"Start":"Paragraph"},{"Text":"Lets test our server out, in one terminal let"},{"Text":"’"},{"Text":"s start the server and in another"},"SoftBreak",{"Text":"we will use "},{"Code":"curl"},{"Text":" to call the endpoint we just created."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"bash"}}},{"Text":"# one terminal\ncargo run\n# the other terminal\ncurl 127.0.0.1:8080 # Hello, world!\n"},{"End":{"CodeBlock":{"Fenced":"bash"}}},{"Start":"Paragraph"},{"Text":"Let"},{"Text":"’"},{"Text":"s add an automatic test for the "},{"Code":"/"},{"Text":" route. Lets start by adding the test"},"SoftBreak",{"Text":"that will create our application."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"rust"}}},{"Text":"// src/main.rs\n#[cfg(test)]\nmod test {\n    use super::app;\n\n    #[tokio::test]\n    async fn hello_world() {\n        let app = app();\n    }\n}\n"},{"End":{"CodeBlock":{"Fenced":"rust"}}},{"Start":"Paragraph"},{"Text":"The "},{"Code":"#[tokio::test]"},{"Text":" will let us create and async test. Let"},{"Text":"’"},{"Text":"s make the request"},"SoftBreak",{"Text":"for the endpoint inside the test."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"rust"}}},{"Text":"// src/main.rs mod test\n// dependencies for the response\nuse axum::{body::Body, http::Request};\nuse tower::ServiceExt; // for oneshot\n\n#[tokio::test]\nasync fn hello_world() {\n    let app = app();\n\n    let response = app\n        .oneshot(Request::builder().uri(\"/\").body(Body::empty()).unwrap())\n        .await\n        .unwrap();\n// ...\n"},{"End":{"CodeBlock":{"Fenced":"rust"}}},{"Start":"Paragraph"},{"Text":"Finally let"},{"Text":"’"},{"Text":"s add the assertions to the test."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"rust"}}},{"Text":"// src/main.rs mod test fn hello_world()\nlet response = ...;\n\nassert_eq!(response.status(), StatusCode::OK);\n\nlet body = hyper::body::to_bytes(response.into_body()).await.unwrap();\nassert_eq!(\u0026body[..], b\"Hello, World!\");\n"},{"End":{"CodeBlock":{"Fenced":"rust"}}},{"Start":"Paragraph"},{"Text":"Now we have a working and tested web server. Lets add some more useful"},"SoftBreak",{"Text":"utilities."},{"End":"Paragraph"},{"Start":"Paragraph"},{"Text":"The first is "},{"Start":{"Link":["Inline","https://docs.rs/color-eyre/latest/color_eyre/",""]}},{"Text":"color-eyre"},{"End":{"Link":["Inline","https://docs.rs/color-eyre/latest/color_eyre/",""]}},{"Text":" to"},"SoftBreak",{"Text":"have a better panic handler."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"bash"}}},{"Text":"cargo add color_eyre\n"},{"End":{"CodeBlock":{"Fenced":"bash"}}},{"Start":"Paragraph"},{"Text":"Then, we have to initialize the panic handler."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"rust"}}},{"Text":"// src/main.rs\nuse color_eyre::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    color_eyre::install()?;\n\n    // ...\n"},{"End":{"CodeBlock":{"Fenced":"rust"}}},{"Start":"Paragraph"},{"Text":"Now we can use the "},{"Code":"?"},{"Text":" in the main function instead of "},{"Code":"unwrap"},{"Text":" for errors. You"},"SoftBreak",{"Text":"can try to run two instances of the program at the same time to see an example"},"SoftBreak",{"Text":"of the eyre errors."},{"End":"Paragraph"},{"Start":"Paragraph"},{"Text":"Finally, we want to log what our server is doing. To do that we will use the"},"SoftBreak",{"Text":"tracing crate, which is already integrated with axum and eyre."},{"End":"Paragraph"},{"Start":"Paragraph"},{"Text":"So let"},{"Text":"’"},{"Text":"s install the tracing dependencies."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"bash"}}},{"Text":"cargo add tracing\ncargo add tracing_subscriber --features=env-filter\ncargo add tower_http --features=trace\n"},{"End":{"CodeBlock":{"Fenced":"bash"}}},{"Start":"Paragraph"},{"Text":"Then, in our "},{"Code":"main.rs"},{"Text":" after the eyre install we have to add the tracing"},"SoftBreak",{"Text":"subscriber."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"rust"}}},{"Text":"// src/main.rs fn main()\ntracing_subscriber::registry()\n    .with(\n        tracing_subscriber::EnvFilter::try_from_default_env()\n            .unwrap_or_else(|_| \"example_testing=debug,tower_http=debug\".into()),\n    )\n    .with(tracing_subscriber::fmt::layer())\n    .init();\n"},{"End":{"CodeBlock":{"Fenced":"rust"}}},{"Start":"Paragraph"},{"Text":"Where "},{"Code":"example_testing"},{"Text":" is the name of our application. This will try to parse"},"SoftBreak",{"Text":"the env filter or use "},{"Code":"debug"},{"Text":" as a default for either our application and"},"SoftBreak",{"Text":"tower."},{"End":"Paragraph"},{"Start":"Paragraph"},{"Text":"Next we add the tracing layer to the tower stack:"},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"rust"}}},{"Text":"// src/main.rs\nfn app() -\u003e Router {\n    Router::new()\n        .route(\"/\", get(|| async { \"Hello, World!\" }))\n        .layer(TraceLayer::new_for_http())\n}\n"},{"End":{"CodeBlock":{"Fenced":"rust"}}},{"Start":"Paragraph"},{"Text":"Finally we can start tracing, let"},{"Text":"’"},{"Text":"s add a debug event for the server address."},{"End":"Paragraph"},{"Start":{"CodeBlock":{"Fenced":"rust"}}},{"Text":"// src/main.rs fn main()\nlet address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)), 8080);\n\ntracing::debug!(\"listing on address {}\", address);\n"},{"End":{"CodeBlock":{"Fenced":"rust"}}}]}},"__N_SSG":true},"page":"/posts/[path]","query":{"path":"2022-12-02_axum_server"},"buildId":"ySP3GZd7gqZ7dTVrh9Bh0","runtimeConfig":{"domain":"joshuachp.dev","production":true},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>